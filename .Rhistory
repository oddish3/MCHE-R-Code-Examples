#Compute probabilities from model
P[['model']]=apollo_mnl(mnl_setting,functionality)
#Take product across observations for same individual
P=apollo_panelProd(P,apollo_inputs,functionality)
#Prepare and return outputs of function
P=apollo_prepareProb(P, apollo_inputs,functionality)
return(P)
}
model=apollo_estimate(apollo_beta,
apollo_fixed,
apollo_probabilities,
apollo_inputs)
apollo_probabilities=function(apollo_beta,apollo_inputs,functionality="estimate"){
apollo_attach(apollo_beta,apollo_inputs)
on.exit(apollo_detach(apollo_beta,apollo_inputs))
#Create list of probabilities
P=list()
#Define utility functions for each alternative (like in NGene)
V=list()
V[['alt1']]=(b_asc12*asc12_1+b_quality*quality_1+b_availability*availability_1+
b_finance*finance_1+b_help*help_1+b_whohelp*whohelp_1+
b_charity*charity_1+b_council*council_1+b_waitime*wait_1+b_cost*cost_1)
V[['alt2']]=(b_asc12*asc12_2+b_quality*quality_2+b_availability*availability_2+
b_finance*finance_2+b_help*help_2+b_whohelp*whohelp_2+
b_charity*charity_2+b_council*council_2+b_waitime*wait_2+b_cost*cost_2)
V[['alt3']]=(b_quality*quality_3+b_availability*availability_3+
b_finance*finance_3+b_help*help_3+b_whohelp*whohelp_3+
b_waitime*wait_3+b_cost*cost_3)
mnl_setting=list(
alternatives=c(alt1=1,alt2=2,alt3=3),
avail=list(alt1=1,alt2=1,alt3=1),
choiceVar=choice,
V=V
)
#Compute probabilities from model
P[['model']]=apollo_mnl(mnl_setting,functionality)
#Take product across observations for same individual
P=apollo_panelProd(P,apollo_inputs,functionality)
#Prepare and return outputs of function
P=apollo_prepareProb(P, apollo_inputs,functionality)
return(P)
}
model=apollo_estimate(apollo_beta,
apollo_fixed,
apollo_probabilities,
apollo_inputs)
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID="participant"
)
#Define dataset
database=finalrun_wide
#Define model parameters
apollo_beta=c(b_asc12=0,
b_quality=0,
b_availability=0,
b_finance=0,
b_help=0,
b_whohelp=0,
b_charity=0,
b_council=0,
b_waitime=0,
b_cost=0
)
#Define any that will stay at starting values
apollo_fixed=c()
#Check Inputs
apollo_inputs=apollo_validateInputs()
#Write user defined probabilities function with model details
#This is essentially the likelihood function
apollo_probabilities=function(apollo_beta,apollo_inputs,functionality="estimate"){
apollo_attach(apollo_beta,apollo_inputs)
on.exit(apollo_detach(apollo_beta,apollo_inputs))
#Create list of probabilities
P=list()
#Define utility functions for each alternative (like in NGene)
V=list()
V[['alt1']]=(b_asc12*asc12_1+b_quality*quality_1+b_availability*availability_1+
b_finance*finance_1+b_help*help_1+b_whohelp*whohelp_1+
b_charity*charity_1+b_council*council_1+b_waitime*wait_1+b_cost*cost_1)
V[['alt2']]=(b_asc12*asc12_2+b_quality*quality_2+b_availability*availability_2+
b_finance*finance_2+b_help*help_2+b_whohelp*whohelp_2+
b_charity*charity_2+b_council*council_2+b_waitime*wait_2+b_cost*cost_2)
V[['alt3']]=(b_quality*quality_3+b_availability*availability_3+
b_finance*finance_3+b_help*help_3+b_whohelp*whohelp_3+
b_waitime*wait_3+b_cost*cost_3)
mnl_setting=list(
alternatives=c(alt1=1,alt2=2,alt3=3),
avail=list(alt1=1,alt2=1,alt3=1),
choiceVar=choice,
V=V
)
#Compute probabilities from model
P[['model']]=apollo_mnl(mnl_setting,functionality)
#Take product across observations for same individual
P=apollo_panelProd(P,apollo_inputs,functionality)
#Prepare and return outputs of function
P=apollo_prepareProb(P, apollo_inputs,functionality)
return(P)
}
model=apollo_estimate(apollo_beta,
apollo_fixed,
apollo_probabilities,
apollo_inputs)
library(readxl)
finalrun_wide <- read_excel("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Iterative Analysis/finalrun wide.xls")
View(finalrun_wide)
finalrun_wide[,1]<-orderv(finalrun_wide[,1])
cbind(finalrun_wide,"charity_3"=c(0),"council_3"=c(0))
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID="participant"
)
#Define dataset
database=finalrun_wide
apollo_beta=c(b_asc12=0,
b_quality=0,
b_availability=0,
b_finance=0,
b_help=0,
b_whohelp=0,
b_charity=0,
b_council=0,
b_waitime=0,
b_cost=0
)
#Define any that will stay at starting values
apollo_fixed=c()
#Check Inputs
apollo_inputs=apollo_validateInputs()
apollo_probabilities=function(apollo_beta,apollo_inputs,functionality="estimate"){
apollo_attach(apollo_beta,apollo_inputs)
on.exit(apollo_detach(apollo_beta,apollo_inputs))
#Create list of probabilities
P=list()
#Define utility functions for each alternative (like in NGene)
V=list()
V[['alt1']]=(b_asc12*asc12_1+b_quality*quality_1+b_availability*availability_1+
b_finance*finance_1+b_help*help_1+b_whohelp*whohelp_1+
b_charity*charity_1+b_council*council_1+b_waitime*wait_1+b_cost*cost_1)
V[['alt2']]=(b_asc12*asc12_2+b_quality*quality_2+b_availability*availability_2+
b_finance*finance_2+b_help*help_2+b_whohelp*whohelp_2+
b_charity*charity_2+b_council*council_2+b_waitime*wait_2+b_cost*cost_2)
V[['alt3']]=(b_quality*quality_3+b_availability*availability_3+
b_finance*finance_3+b_help*help_3+b_whohelp*whohelp_3+
b_waitime*wait_3+b_cost*cost_3)
mnl_setting=list(
alternatives=c(alt1=1,alt2=2,alt3=3),
avail=list(alt1=1,alt2=1,alt3=1),
choiceVar=choice,
V=V
)
#Compute probabilities from model
P[['model']]=apollo_mnl(mnl_setting,functionality)
#Take product across observations for same individual
P=apollo_panelProd(P,apollo_inputs,functionality)
#Prepare and return outputs of function
P=apollo_prepareProb(P, apollo_inputs,functionality)
return(P)
}
model=apollo_estimate(apollo_beta,
apollo_fixed,
apollo_probabilities,
apollo_inputs)
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=finalrun_wide[,1]
)
database=finalrun_wide
#Define model parameters
apollo_beta=c(b_asc12=0,
b_quality=0,
b_availability=0,
b_finance=0,
b_help=0,
b_whohelp=0,
b_charity=0,
b_council=0,
b_waitime=0,
b_cost=0
)
#Define any that will stay at starting values
apollo_fixed=c()
#Check Inputs
apollo_inputs=apollo_validateInputs()
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=as.numeric(finalrun_wide[,1])
)
typeof(finalrun_wide[,1])
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=unlist(finalrun_wide[,1])
)
#Define dataset
database=finalrun_wide
#Check Inputs
apollo_inputs=apollo_validateInputs()
View(finalrun_wide)
View(finalrun_wide)
View(finalrun_wide)
View(finalrun_wide)
library(readxl)
finalrun_wide <- read_excel("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Iterative Analysis/finalrun wide.xls")
View(finalrun_wide)
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=participant
)
cbind(finalrun_wide,"charity_3"=c(0),"council_3"=c(0))
#Define dataset
database=finalrun_wide
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID="participant"
)
#Define model parameters
apollo_beta=c(b_asc12=0,
b_quality=0,
b_availability=0,
b_finance=0,
b_help=0,
b_whohelp=0,
b_charity=0,
b_council=0,
b_waitime=0,
b_cost=0
)
#Define any that will stay at starting values
apollo_fixed=c()
#Check Inputs
apollo_inputs=apollo_validateInputs()
finalrun_wide[1,]
finalrun_wide[,1]
c(finalrun_wide[,1])
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=c(finalrun_wide[,1])
)
#Define dataset
database=finalrun_wide
#Check Inputs
apollo_inputs=apollo_validateInputs()
typeof(finalrun_wide)
final_runwide<-as.data.frame(finalrun_wide)
cbind(finalrun_wide,"charity_3"=c(0),"council_3"=c(0))
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=c(finalrun_wide[,1])
)
#Define dataset
database=finalrun_wide
#Define model parameters
apollo_beta=c(b_asc12=0,
b_quality=0,
b_availability=0,
b_finance=0,
b_help=0,
b_whohelp=0,
b_charity=0,
b_council=0,
b_waitime=0,
b_cost=0
)
#Define any that will stay at starting values
apollo_fixed=c()
#Check Inputs
apollo_inputs=apollo_validateInputs()
typeof(finalrun_wide)
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=c(final_runwide[,1])
)
#Define dataset
database=final_runwide
#Check Inputs
apollo_inputs=apollo_validateInputs()
View(final_runwide)
View(final_runwide)
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID=participant
)
#Feed in basic details for model
apollo_control=list(
modelName="clogit",
modelDescr="Conditional logit",
indivID="participant"
)
#Check Inputs
apollo_inputs=apollo_validateInputs()
apollo_probabilities=function(apollo_beta,apollo_inputs,functionality="estimate"){
apollo_attach(apollo_beta,apollo_inputs)
on.exit(apollo_detach(apollo_beta,apollo_inputs))
#Create list of probabilities
P=list()
#Define utility functions for each alternative (like in NGene)
V=list()
V[['alt1']]=(b_asc12*asc12_1+b_quality*quality_1+b_availability*availability_1+
b_finance*finance_1+b_help*help_1+b_whohelp*whohelp_1+
b_charity*charity_1+b_council*council_1+b_waitime*wait_1+b_cost*cost_1)
V[['alt2']]=(b_asc12*asc12_2+b_quality*quality_2+b_availability*availability_2+
b_finance*finance_2+b_help*help_2+b_whohelp*whohelp_2+
b_charity*charity_2+b_council*council_2+b_waitime*wait_2+b_cost*cost_2)
V[['alt3']]=(b_quality*quality_3+b_availability*availability_3+
b_finance*finance_3+b_help*help_3+b_whohelp*whohelp_3+
b_waitime*wait_3+b_cost*cost_3)
mnl_setting=list(
alternatives=c(alt1=1,alt2=2,alt3=3),
avail=list(alt1=1,alt2=1,alt3=1),
choiceVar=choice,
V=V
)
#Compute probabilities from model
P[['model']]=apollo_mnl(mnl_setting,functionality)
#Take product across observations for same individual
P=apollo_panelProd(P,apollo_inputs,functionality)
#Prepare and return outputs of function
P=apollo_prepareProb(P, apollo_inputs,functionality)
return(P)
}
model=apollo_estimate(apollo_beta,
apollo_fixed,
apollo_probabilities,
apollo_inputs)
apollo_modelOutput(model)
install.packages("shiny")
install.packages("ggplot2")
install.packages("rsconnect")
rsconnect::setAccountInfo(name='stuwrighthealthecon',
token='155D009D59E270362E7C6F99634DC5BA',
secret='AeXhc2xT5yiF1+SMHXMvfC7XBz9/14wRJlFUlIqH')
rsconnect::deployApp("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app")
shiny::runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
rsconnect:showlogs()
rsconnect::showlogs()
rsconnect::showLogs()
rsconnect::showLogs("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app")
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
rsconnect::deployApp("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app")
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
rsconnect::deployApp("C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app")
shiny::runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
costvector<-c(seq(from=0,to=3000,by=100))
uptake<-data.frame("Cost"=costvector,
"Uptake"=vector(mode="numeric",length=length(costvector)))
print(uptake)
runApp('C:/Users/mdxassw4/Dropbox (The University of Manchester)/PRESENCE/Shiny app')
failure<-c(0.25,0.4)
library("fitdistr")
library("fitdistrplus")
install.packages("fitdistrplus")
library("fitdistrplus")
fitdit(failure,"beta")
fitdist(failure,"beta")
invites<-c(2,8.03)
fitdist(invite,"gamma")
fitdist(invites,"gamma")
fitdist(invites,"normal")
fitdist(invites,"norm")
entertc<-c(12.5,30)
ditdist(entertc,"norm")
fitdist(entertc,"norm")
imagefail<-c(7.5,5)
fitdist(imagefail,"norm")
organise<-c(1.5,3)
fitdist(organise,"norm")
clinicpack<-c(5,30)
fitdist(clinicpack,"norm")
mobvans<-(data.frame(read.csv("C:/Users/mdxassw4/Dropbox (The University of Manchester)/MERCADO/Microcosting/Mobile vans cost.csv"))
print(mobvans)
mobvans<-(data.frame(read.csv("C:/Users/mdxassw4/Dropbox (The University of Manchester)/MERCADO/Microcosting/Mobile vans cost.csv")))
print(mobvans)
fit.dist(mobvans[,1],"gamma")
library("fitdistrplus")
fit.dist(mobvans[,1],"gamma")
fitdist(mobvans[,1],"gamma")
summary.fitdist(mobvans[,1],"gamma")
gammamob<-fitdist(mobvans[,1],"gamma")
summary(gammamob)
lnormmob<-fitdist(mobvans[,1],"lnorm")
summary(lnormmob)
normmob<-fitdist(mobvans[,1],"norm")
summary(normmob)
mobvans[,1]
imagefail<-c(7.5,5)
summary(lnormmob)
summary(normmob)
summary(lnormmob)
install.packages("rrriskDistributions")
install.packages("rriskDistributions")
library("rriskDistributions")
get.norm.par(p=c(0.025,0.5,0.975),q=c(5,7.5,10))
#Then lets ask fitdistrplus to fit a normal distribution (we could do
#this pretty easily ourselves). Here we use the fitdist function and
#give it two arguments 1) the vector of observations and 2) a short
#name of the distribution to be estimated
fitdist(imagefail,"norm")
failure<-c(0.25,0.4)
fitdist(failure,"beta")
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("Mobile vans cost.csv")))
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("Mobile vans cost.csv")))
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv(/"Mobile vans cost.csv")))
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("/Mobile vans cost.csv")))
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("Mobile vans cost.csv")))
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("Mobile vans cost.csv")))
#Set your directory
setwd("C:/Users/mdxassw4/Documents/GitHub/MCHE-R-Code-Examples")
#We can of course use bigger data sets. Lets look at the number of
#breast screens offered by every trust in the UK. This sheet just
#has the numbers not the trusts
numscreens<-(data.frame(read.csv("Mobile vans cost.csv")))
#Lets see what the data looks like
density(numscreens[,1])
#Lets see what the data looks like
print(density(numscreens[,1]))
#Lets see what the data looks like
plot(density(numscreens[,1]))
#Lets start with the normal
normmob<-fitdist(mobvans[,1],"norm")
#And lets check the fit (AIC/BIC stats)
summary(normmob)
plot(normob)
plot(normmob)
plot(normmob)
plot(normmob)
plot(normmob[1])
plot(normmob[,1])
#And lets check the fit (AIC/BIC stats)
summary(normmob[3])
plot(normmob[3])
plot(normmob[5])
#Lets start with the normal
normmob<-fitdist(mobvans[,1],"norm")
plot(normmob)[1]
plot(normmob)[2]
plotdist(normmob)
denscomp(list(normmob))
denscomp(list(normmob))
gammamob<-fitdist(mobvans[,1],"gamma")
denscomp(list(normmob))
#Lets see what the data looks like
plot(density(numscreens[,1]))
#Lets start with the normal
normscreen<-fitdist(numscreens[,1],"norm")
#And lets check the fit (AIC/BIC stats)
summary(normmob)
#And lets check the fit (AIC/BIC stats)
summary(normscreen)
#What does the distribution look like vs the data
#hmm not great
denscomp(list(normscreen))
gammascreen<-fitdist(numscreens[,1],"gamma")
summary(gammascreens)
denscomp(list(normscreens,gammascreens))
gammascreen<-fitdist(numscreens[,1],"gamma")
summary(gammascreen)
denscomp(list(normscreens,gammascreen))
gammascreen<-fitdist(numscreens[,1],"gamma")
summary(gammascreen)
denscomp(list(normscreen,gammascreen))
lnormscreen<-fitdist(numscreens[,1],"lnorm")
summary(lnormscreen)
denscomp(list(normscreen,gammascreen,lnormscreen))
